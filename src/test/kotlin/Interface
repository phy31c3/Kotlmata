object {}
object method {}
object method object
object method object method {}

object method [object {}]

remove clear delete drop erase

[State]————————————————————————————————————————————————————————————————————————————————
// KotlmataState는 추상 클래스

KotlmataState("name") {
	entry action [action]
	entry via "signal" action [action]
	event input "signal" action [action]
	event input stateKey action [action]
	exit action [action]
}

KotlmataState {
	entry action [action]
	exit action [action]
}

val immutableState = KotlmataState() // 불가
val mutableState = KotlmataMutableState()

mutableState {
	entry action [action]
	entry via "signal" action [action]

	entry action delete
	exit action delete
	entry via any action delete
	entry via "signal" action delete
	event input all action delete
	event input "signal" action delete

	delete all actions
}

mutableState.entry() {
	event(it)
}
mutableState.entry("signal") {
	event(it)
}
mutableState.event("signal")
mutableState.exit()

[Machine]————————————————————————————————————————————————————————————————————————————————
KotlmataMachine("name") {
	"state0" {
		base is "state1"
		entry action [action]
		entry via "signal" action [action]
		event input "signal" action {
			stateKey
			machineKey
			// 여기서 신규 state를 어떻게 만들까
		}
		exit action [action]
	}

	"state2" {}
	"state3" {base is "state1"}

	// 전이 규칙 복사 : 만약 뒤에 state1의 전이 규칙이 바뀐다면 어떻게.. (결국 state처럼 상속 개념으로?)
	copy transition rule of "state1" to "state0"
	"state0" X "signal" to "state1"
	"state1" x "signal" to "state2"

	initialize origin state to "state0"
}

val immutableMachine = KotlmataMachine {
	initialize origin state to "state0"
}

val mutableMachine = KotlmataMutableMachine {
	initialize origin state to "state0"
}

mutableMachine {
	// 이미 state가 존재하면 건너뛰는 문법도 필요함..
	"state1" replace {
		base is "state0"
		entry action [action]
		entry via "signal" action [action]
		event input "signal" action [action]
		exit action [action]
	}

	"state1" update {
		base is "state1" // 불가
		entry via "signal" action [action]
		event input "signal" action [action]

		entry action delete
		exit action delete
	}

	"state0" X "signal" to "state1"

	delete state "state1"
	delete transition ("state0" X "signal")
	delete transition all from "state0"
	delete transition all to "state1"

	delete all states
	delete all transitions
}

mutableMachine.input("signal")
mutableMachine.input(object, Any::class) // <T : Any> input(signal: T, type: KClass<in T>)

[Daemon]————————————————————————————————————————————————————————————————————————————————
KotlmataDaemon("name") {
	on start [action] // 최초 시작 시
	on pause [action]
	on stop [action]
	on resume [action] // 일시정지 혹은 정지 상태에서 재개될 시
	on terminate [action] // 완전 종료 시

	// Machine이랑 동일

	initialize origin state to "state0"
}.run()

val mutableDaemon = KotlmataMutableDaemon {
	on start [action]
	initialize origin state to "state0"
}

mutableDaemon {
	// Machine이랑 동일
}

mutableDaemon.run()
mutableDaemon.pause()
mutableDaemon.stop()
mutableDaemon.terminate()

mutableDaemon.input("signal")
mutableDaemon.input(object, Any::class)

[Kotlmata]————————————————————————————————————————————————————————————————————————————————
Kotlmata init {
	print...
}